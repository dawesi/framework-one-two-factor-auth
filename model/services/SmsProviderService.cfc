component displayname="SmsProviderService" accessors="true" {	// PUBLIC METHODS //	// CREATE //	/**	* @displayname	createNewSmsProvider	* @description	I insert a new smsProvider record into the smsProviders table in the database	* @param		smsProvider {Any} I am the SmsProvider bean	* @returnType	numeric	*/	public numeric function createNewSmsProvider( required any smsProvider ) {		var qPutSmsProvider = '';		var queryService = new query();		var sql = '';		try {			sql = 'INSERT INTO smsProviders ( provider, email, isActive ) VALUES ( :provider, :email, :isActive )';			queryService.setSQL( sql );			queryService.addParam( name='provider', value='#arguments.smsProvider.getProvider()#', cfsqltype='cf_sql_varchar' );			queryService.addParam( name='email', value='#arguments.smsProvider.getEmail()#', cfsqltype='cf_sql_varchar' );			queryService.addParam( name='isActive', value='#arguments.smsProvider.getIsActive()#', cfsqltype='cf_sql_bit' );			qPutSmsProvider = queryService.execute();		// catch any errors //		} catch (any e) {			writeDump( e );			abort;		}		return qPutSmsProvider.getPrefix().IDENTITYCOL;	}	// RETRIEVE - BY ID //	/**	* @displayname	getSmsProviderByID	* @description	I return a SmsProvider bean populated with the details of a specific smsProvider record	* @param		id {Numeric} I am the numeric auto-increment id of the smsProvider to search for	* @returnType	any	*/	public any function getSmsProviderByID( required numeric id ) {		var qGetSmsProvider = '';		var queryService = new query();		var smsProviderObject = createObject( 'component', 'model.beans.SmsProvider' );		var sql = '';		try {			sql = 'SELECT providerId, provider, email, isActive FROM smsProviders WHERE providerId = :id';			queryService.setSQL( sql );			queryService.addParam( name = 'id', value = '#arguments.id#', cfsqltype = 'cf_sql_integer' );			qGetSmsProvider = queryService.execute().getResult();		// catch any errors //		} catch (any e) {			writeDump( e );			abort;		}		if( qGetSmsProvider.RecordCount ) {			return smsProviderObject.init(				providerId		= qGetSmsProvider.providerId,				provider		= qGetSmsProvider.provider,				email			= qGetSmsProvider.email,				isActive		= qGetSmsProvider.isActive			);		} else {			return smsProviderObject.init();		}	}	// UPDATE //	/**	* @displayname	updateSmsProvider	* @description	I update this smsProvider record in the smsProviders table of the database	* @param		smsProvider {Any} I am the SmsProvider bean	* @returnType	numeric	*/	public numeric function updateSmsProvider( required any smsProvider ) {		var qUpdSmsProvider = '';		var queryService = new query();		var sql = '';		try {			sql = 'UPDATE smsProviders SET provider = :provider, email = :email, isActive = :isActive WHERE providerId = :providerId';			queryService.setSQL( sql );			queryService.addParam( name = 'providerId', value = '#arguments.smsProvider.getProviderId()#', cfsqltype = 'cf_sql_int' );			queryService.addParam( name = 'provider', value = '#arguments.smsProvider.getProvider()#', cfsqltype = 'cf_sql_varchar' );			queryService.addParam( name = 'email', value = '#arguments.smsProvider.getEmail()#', cfsqltype = 'cf_sql_varchar' );			queryService.addParam( name = 'isActive', value = '#arguments.smsProvider.getIsActive()#', cfsqltype = 'cf_sql_bit' );			qUpdSmsProvider = queryService.execute().getResult();		// catch any errors //		} catch (any e) {			writeDump( e );			abort;		}		return arguments.smsProvider.getProviderId();	}	// DELETE //	/**	* @displayname	deleteSmsProviderByID	* @description	I delete a smsProvider record from the smsProviders table in the database	* @param		id {Numeric} I am the numeric auto-increment id of the smsProvider to delete	* @returnType	boolean	*/	public boolean function deleteSmsProviderByID( required numeric id ) {		var qDelSmsProvider = '';		var queryService = new query();		var sql = 'DELETE FROM smsProviders WHERE providerId = :id';		try {			queryService.setSQL( sql );			queryService.addParam( name = 'id', value = '#arguments.id#', cfsqltype = 'cf_sql_integer' );			qDelSmsProvider = queryService.execute().getResult();		// catch any errors //		} catch (any e) {			writeDump( e );			abort;		}		return true;	}	// UTILITY METHODS //	// SAVE //	/**	* @displayname	saveSmsProviderByID	* @description	I save a smsProvider record in the smsProviders table in the database	* @param		smsProvider {Any} I am the SmsProvider bean	* @returnType	numeric	*/	public numeric function saveSmsProvider( required any smsProvider ) {		if( exists( arguments.smsProvider ) ) {			return updateSmsProvider( arguments.smsProvider );		} else {			return createNewSmsProvider( arguments.smsProvider );		}	}	// EXISTS //	/**	* @displayname	exists	* @description	I check if a smsProvider record exists in the smsProviders table in the database	* @param		smsProvider {Any} I am the SmsProvider bean	* @returnType	boolean	*/	public boolean function exists( required any smsProvider ) {		var qGetSmsProvider = '';		var queryService = new query();		var sql = 'SELECT providerId FROM smsProviders WHERE providerId = :providerId';		queryService.setSQL( sql );		queryService.addParam( name = 'providerId', value = '#arguments.smsProvider.getProviderId()#', cfsqltype = 'cf_sql_integer' );		qGetSmsProvider = queryService.execute().getResult();		if( qGetSmsProvider.recordCount ) {			return true;		} else {			return false;		}	}	// FILTER //	/**	* @displayname	filter	* @description	I run a filtered query of all records within the smsProviders table in the database	* @param		returnColumns {String} I am the columns in the smsProviders table that should be returned in this query (default: all columns)	* @param		provider {String} I am the value for provider in the smsProviders table that should be returned in this query	* @param		email {String} I am the value for email in the smsProviders table that should be returned in this query	* @param		isActive {Boolean} I am the value for isActive in the smsProviders table that should be returned in this query	* @param		orderBy {String} I am the order to return records in the smsProviders table returned in this query	* @param		cache {Boolean} I am a flag (true/false) to determine if this query should be cached (default: false)	* @param		cacheTime {Any} I am the timespan the query should be cached for (default: 1 hour)	* @returnType	query	*/	public query function filter(		string returnColumns = 'providerId, provider, email, isActive', 		string provider, 		string email, 		boolean isActive, 		string orderBy,		boolean cache = false,		any cacheTime = createTimeSpan(0,1,0,0)	) {		var thisFilter = structNew();		if( isDefined( 'arguments.provider' ) AND len( arguments.provider ) ) {			thisFilter.provider = arguments.provider;		}		if( isDefined( 'arguments.email' ) AND len( arguments.email ) ) {			thisFilter.email = arguments.email;		}		if( isDefined( 'arguments.isActive' ) AND len( arguments.isActive ) ) {			thisFilter.isActive = arguments.isActive;		}		if( isDefined( 'arguments.orderBy' ) AND len( arguments.orderBy ) ) {			thisFilter.order_by = arguments.orderBy;		}		if( isDefined( 'arguments.cache' ) AND len( arguments.cache ) ) {			thisFilter.cache = arguments.cache;		}		thisFilter.returnColumns = arguments.returnColumns;		if( !structIsEmpty( thisFilter ) AND structKeyExists( thisFilter, 'cache' ) AND thisFilter.cache ) {			return cacheFilteredSmsProviderRecords( thisFilter, arguments.cacheTime );		} else { 			return filterSmsProviderRecords( thisFilter );		}	}	// PRIVATE METHODS //	// QUERY - CACHE FILTERED SMSPROVIDER RECORDS //	/**	* @displayname	cacheFilteredSmsProviderRecords	* @description	I run a query that will cache and return all smsProvider records. If a filter has been applied, I will refine results based on the filter	* @param		filter {Struct} I am the filter struct to apply to this query	* @param		cacheTime {Time} I am the time to cache this query (use createTimeSpan)	* @returnType	query	*/	private query function cacheFilteredSmsProviderRecords( struct filter = {}, cacheTime = createTimeSpan( 0, 1, 0, 0 ) ) {		var cachedQueryName = hash( serializeJSON( arguments.filter ), 'MD5' );		var queryService = new query( name = cachedQueryName, cachedWithin = arguments.cacheTime );		var sql = 'SELECT #arguments.filter.returnColumns# FROM smsProviders WHERE 1 = 1 ';		if( !structIsEmpty( arguments.filter ) ) {			// filter is applied //			if( structKeyExists( arguments.filter, 'provider' ) ) {				sql = sql & 'AND provider = :provider ';				queryService.addParam( name = 'provider', value = '#arguments.filter.provider#', cfsqltype = 'cf_sql_varchar' );			}			if( structKeyExists( arguments.filter, 'email' ) ) {				sql = sql & 'AND email = :email ';				queryService.addParam( name = 'email', value = '#arguments.filter.email#', cfsqltype = 'cf_sql_varchar' );			}			if( structKeyExists( arguments.filter, 'isActive' ) ) {				sql = sql & 'AND isActive = :isActive ';				queryService.addParam( name = 'isActive', value = '#arguments.filter.isActive#', cfsqltype = 'cf_sql_bit' );			}			if( structKeyExists( arguments.filter, 'order_by' ) ) {				sql = sql & 'ORDER BY #arguments.filter.order_by#';			}		}		return queryService.setSQL( sql ).execute().getResult();	}	// QUERY - FILTER SMSPROVIDER RECORDS //	/**	* @displayname	filterSmsProviderRecords	* @description	I run a query that will return all smsProvider records. If a filter has been applied, I will refine results based on the filter	* @param		filter {Struct} I am the filter struct to apply to this query	* @returnType	query	*/	private query function filterSmsProviderRecords( struct filter = {} ) {		var queryService = new query();		var sql = 'SELECT #arguments.filter.returnColumns# FROM smsProviders WHERE 1 = 1 ';		if( !structIsEmpty( arguments.filter ) ) {			// filter is applied //			if( structKeyExists( arguments.filter, 'provider' ) ) {				sql = sql & 'AND provider = :provider ';				queryService.addParam( name = 'provider', value = '#arguments.filter.provider#', cfsqltype = 'cf_sql_varchar' );			}			if( structKeyExists( arguments.filter, 'email' ) ) {				sql = sql & 'AND email = :email ';				queryService.addParam( name = 'email', value = '#arguments.filter.email#', cfsqltype = 'cf_sql_varchar' );			}			if( structKeyExists( arguments.filter, 'isActive' ) ) {				sql = sql & 'AND isActive = :isActive ';				queryService.addParam( name = 'isActive', value = '#arguments.filter.isActive#', cfsqltype = 'cf_sql_bit' );			}			if( structKeyExists( arguments.filter, 'order_by' ) ) {				sql = sql & 'ORDER BY #arguments.filter.order_by#';			}		}		return queryService.setSQL( sql ).execute().getResult();	}}